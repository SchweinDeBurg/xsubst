// SubstSvc NT service.
// Copyright (c) 2004 by Elijah Zarezky,
// All rights reserved.

// ServiceCore.cpp - core service routines
// initially generated by AfxScratch 1.0.2290 on 18.07.2004 at 11:12:43

#include "stdafx.h"
#include "ExecLogging.h"
#include "Resource.h"
#include "SubstSvcApp.h"

#if defined(_DEBUG)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif	// _DEBUG

static int EnumDrivesKey(BOOL (__cdecl* pfnCallback)(LPCTSTR, LPCTSTR))
{
	CString strKeyName;
	CString strRegistryKey;		// for logging
	CRegKey regKey;
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];

	// build key name
	strKeyName.LoadString(IDS_REGISTRY_KEY);
	strKeyName.Insert(0, _T("Software\\"));
	strKeyName += _T('\\');
	strKeyName += AfxGetAppName();
	strKeyName += _T("\\Drives");
	strRegistryKey.Format(_T("HKCU\\%s registry key"), static_cast<LPCTSTR>(strKeyName));

	HKEY hkDrives = NULL;
	::RegCreateKey(HKEY_CURRENT_USER, strKeyName, &hkDrives);
	if (hkDrives != NULL) {
		WriteLogFileEntry(LL_MINIMAL, _T("Opened %s."), static_cast<LPCTSTR>(strRegistryKey));
		regKey.Attach(hkDrives);
		int cNumDrives = 0;
		BOOL fHasValue = TRUE;
		for (int i = 0; fHasValue; ++i) {
			DWORD cchName = _MAX_DRIVE;
			DWORD fdwType = REG_NONE;
			LONG nResult = ::RegEnumValue(hkDrives, i, szDrive, &cchName, NULL, &fdwType, NULL, NULL);
			if (nResult == ERROR_NO_MORE_ITEMS) {
				// no more values - so break the loop
				fHasValue = FALSE;
			}
			else if (nResult == ERROR_SUCCESS) {
				// only string values are interested
				if (fdwType == REG_SZ) {
					DWORD cchValue = _MAX_PATH;
					if (regKey.QueryValue(szPath, szDrive, &cchValue) == ERROR_SUCCESS) {
						(*pfnCallback)(szDrive, szPath) ? ++cNumDrives : (void)0;
					}
				}
			}
			else {
				// what the shit is that?!
			}
		}
		regKey.Detach();
		if (::RegCloseKey(hkDrives) == ERROR_SUCCESS) {
			WriteLogFileEntry(LL_MINIMAL, _T("Closed %s."), static_cast<LPCTSTR>(strRegistryKey));
		}
		return (cNumDrives);
	}
	else {
		WriteLogFileEntry(LL_MINIMAL, _T("Failed to access %s."), static_cast<LPCTSTR>(strRegistryKey));
		return (0);
	}
}

static BOOL SubstCreate(LPCTSTR pszDrive, LPCTSTR pszPath)
{
	if (::DefineDosDevice(0, pszDrive, pszPath)) {
		WriteLogFileEntry(LL_MINIMAL, _T("Substituted %s for %s."), pszDrive, pszPath);
		return (TRUE);
	}
	else {
		WriteLogFileEntry(LL_MINIMAL, _T("Failed to sustitute %s for %s."), pszDrive, pszPath);
		return (FALSE);
	}
}

// startup thread procedure
static UINT StartupProc(void* /*pParam*/)
{
	WriteLogFileEntry(LL_MINIMAL, _T("Started startup thread."));

	// create initial substitutions
	int cDrivesSubst = EnumDrivesKey(SubstCreate);
	WriteLogFileEntry(LL_MINIMAL, _T("Total substituted %i drive(s)."), cDrivesSubst);

	// successfully finished
	WriteLogFileEntry(LL_MINIMAL, _T("Finished startup thread."));
	AfxEndThread(0);
	return (0);
}

// control handler function of a service
void WINAPI ServiceHandler(DWORD fdwControl)
{
	SERVICE_STATUS ss;

	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	switch (fdwControl)
	{
	case SERVICE_CONTROL_STOP:
		WriteLogFileEntry(LL_MINIMAL, _T("Requested to stop %s service."), g_szServiceName);
		ss.dwCurrentState = SERVICE_STOPPED;
		g_dwServiceState = ss.dwCurrentState;
		break;
	default:
		ss.dwCurrentState = g_dwServiceState;
		break;
	}
	ss.dwControlsAccepted = SERVICE_ACCEPT_STOP;
	ss.dwWin32ExitCode = NO_ERROR;
	ss.dwServiceSpecificExitCode = 0;	// will be ignored
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;
	::SetServiceStatus(g_hServiceStatus, &ss);
	if (g_dwServiceState == SERVICE_STOPPED) {
		WriteLogFileEntry(LL_MINIMAL, _T("Stopped %s service."), g_szServiceName);
	}
}

// service entry-point function
void WINAPI ServiceMain(DWORD /*dwArgc*/, LPTSTR /*apszArgv*/[])
{
	SERVICE_STATUS ss;

	g_hServiceStatus = ::RegisterServiceCtrlHandler(g_szServiceName, ServiceHandler);
	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	ss.dwCurrentState = SERVICE_RUNNING;
	ss.dwControlsAccepted = SERVICE_ACCEPT_STOP;
	ss.dwWin32ExitCode = NO_ERROR;
	ss.dwServiceSpecificExitCode = 0;	// will be ignored
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;
	::SetServiceStatus(g_hServiceStatus, &ss);
	g_dwServiceState = ss.dwCurrentState;
	WriteLogFileEntry(LL_MINIMAL, _T("Runned %s service."), g_szServiceName);
	AfxBeginThread(StartupProc, NULL);
}

// end of file
