// SubstSvc NT service.
// Copyright (c) 2004 by Elijah Zarezky,
// All rights reserved.

// ServiceCore.cpp - core service routines
// initially generated by AfxScratch 1.0.2290 on 18.07.2004 at 11:12:43

#include "stdafx.h"
#include "ExecLogging.h"
#include "Resource.h"
#include "ServiceInterop.h"
#include "SubstSvcApp.h"

#if defined(_DEBUG)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif	// _DEBUG

static int EnumDrivesKey(BOOL (__cdecl* pfnCallback)(CRegKey&, LPCTSTR, LPCTSTR))
{
	CString strKeyName;
	CString strRegistryKey;		// for logging
	CRegKey regKey;
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szPath[_MAX_PATH];

	// build key name
	strKeyName.LoadString(IDS_REGISTRY_KEY);
	strKeyName.Insert(0, _T("Software\\"));
	strKeyName += _T('\\');
	strKeyName += AfxGetAppName();
	strKeyName += _T("\\Drives");
	strRegistryKey.Format(_T("HKCU\\%s registry key"), static_cast<LPCTSTR>(strKeyName));

	if (regKey.Create(HKEY_CURRENT_USER, strKeyName) == ERROR_SUCCESS) {
		LogFile_WriteEntry(LL_MINIMAL, _T("Opened %s."), static_cast<LPCTSTR>(strRegistryKey));
		int cNumDrives = 0;
		BOOL fHasValue = TRUE;
		for (int i = 0; fHasValue; ++i) {
			DWORD cchName = _MAX_DRIVE;
			DWORD fdwType = REG_NONE;
			LONG nResult = ::RegEnumValue(regKey, i, szDrive, &cchName, NULL, &fdwType, NULL, NULL);
			if (nResult == ERROR_NO_MORE_ITEMS) {
				// no more values - so break the loop
				fHasValue = FALSE;
			}
			else if (nResult == ERROR_SUCCESS) {
				// only string values are interested
				if (fdwType == REG_SZ) {
					DWORD cchValue = _MAX_PATH;
					if (regKey.QueryValue(szPath, szDrive, &cchValue) == ERROR_SUCCESS) {
						(*pfnCallback)(regKey, szDrive, szPath) ? ++cNumDrives : (void)0;
					}
				}
			}
			else {
				// what the shit is that?!
			}
		}
		if (regKey.Close() == ERROR_SUCCESS) {
			LogFile_WriteEntry(LL_MINIMAL, _T("Closed %s."), static_cast<LPCTSTR>(strRegistryKey));
		}
		return (cNumDrives);
	}
	else {
		LogFile_WriteEntry(LL_MINIMAL, _T("Failed to access %s."), static_cast<LPCTSTR>(strRegistryKey));
		return (0);
	}
}

static BOOL SubstCreate(CRegKey& /*regKey*/, LPCTSTR pszDrive, LPCTSTR pszPath)
{
	if (::DefineDosDevice(0, pszDrive, pszPath)) {
		LogFile_WriteEntry(LL_MINIMAL, _T("Substituted %s for %s."), pszDrive, pszPath);
		return (TRUE);
	}
	else {
		LogFile_WriteEntry(LL_MINIMAL, _T("Failed to sustitute %s for %s."), pszDrive, pszPath);
		return (FALSE);
	}
}

static BOOL SubstModify(CRegKey& regKey, LPCTSTR pszDrive, LPCTSTR pszPath)
{
	if (pszPath[0] == _T('+')) {
		// create new substitution
		if (::DefineDosDevice(0, pszDrive, &pszPath[1])) {
			LogFile_WriteEntry(LL_MINIMAL, _T("Substituted %s for %s."), pszDrive, &pszPath[1]);
			regKey.SetValue(&pszPath[1], pszDrive);
			return (TRUE);
		}
		else {
			LogFile_WriteEntry(LL_MINIMAL, _T("Failed to substitute %s for %s."), pszDrive, &pszPath[1]);
			return (FALSE);
		}
	}
	else if (pszPath[0] == _T('*')) {
		// modify existing substitution
		LPTSTR pszPrevPath = new TCHAR[_MAX_PATH];
		if (::QueryDosDevice(pszDrive, pszPrevPath, _MAX_PATH) > 0) {
			// first remove current substitution...
			if (::DefineDosDevice(DDD_REMOVE_DEFINITION, pszDrive, pszPrevPath)) {
				LogFile_WriteEntry(LL_MINIMAL, _T(""), pszDrive, pszPrevPath);
			}
			else {
				LogFile_WriteEntry(LL_MINIMAL, _T(""), pszDrive, pszPrevPath);
			}
		}
		delete[] pszPrevPath;
		// ...and then create a new one
		if (::DefineDosDevice(0, pszDrive, &pszPath[1])) {
			LogFile_WriteEntry(LL_MINIMAL, _T("Substituted %s for %s."), pszDrive, &pszPath[1]);
			regKey.SetValue(&pszPath[1], pszDrive);
			return (TRUE);
		}
		else {
			LogFile_WriteEntry(LL_MINIMAL, _T("Failed to substitute %s for %s."), pszDrive, &pszPath[1]);
			return (FALSE);
		}
	}
	else {
		// nothing to do
		return (FALSE);
	}
}

// startup thread procedure
static UINT StartupProc(void* /*pParam*/)
{
	LogFile_WriteEntry(LL_MINIMAL, _T("Started startup thread."));

	// create initial substitutions
	int cDrivesSubst = EnumDrivesKey(SubstCreate);
	LogFile_WriteEntry(LL_MINIMAL, _T("Total substituted %i drive(s)."), cDrivesSubst);

	// successfully finished
	LogFile_WriteEntry(LL_MINIMAL, _T("Finished startup thread."));
	AfxEndThread(0);
	return (0);
}

// control handler function of a service
void WINAPI ServiceHandler(DWORD fdwControl)
{
	SERVICE_STATUS ss;
	HANDLE hEvent;
	int cDrivesSubst;

	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	switch (fdwControl)
	{
	case SERVICE_CONTROL_SHUTDOWN:
		LogFile_WriteEntry(LL_MINIMAL, _T("Detected operating system shutdown."));
		// fall through
	case SERVICE_CONTROL_STOP:
		LogFile_WriteEntry(LL_MINIMAL, _T("Requested to stop %s service."), g_szServiceName);
		ss.dwCurrentState = SERVICE_STOPPED;
		g_dwServiceState = ss.dwCurrentState;
		break;
	case SUBSTSVC_SERVICE_CONTROL_MODIFY_DRIVES:
		LogFile_WriteEntry(LL_MINIMAL, _T("Requested to modify current substitutions."));
		cDrivesSubst = EnumDrivesKey(SubstModify);
		LogFile_WriteEntry(LL_MINIMAL, _T("Total modified %i substitution(s)."), cDrivesSubst);
		hEvent = ::OpenEvent(EVENT_MODIFY_STATE, FALSE, SZ_SYNC_EVENT_NAME);
		::SetEvent(hEvent);
		::CloseHandle(hEvent);
		// fall through
	default:
		ss.dwCurrentState = g_dwServiceState;
		break;
	}
	ss.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
	ss.dwWin32ExitCode = NO_ERROR;
	ss.dwServiceSpecificExitCode = 0;	// will be ignored
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;
	::SetServiceStatus(g_hServiceStatus, &ss);
	if (g_dwServiceState == SERVICE_STOPPED) {
		LogFile_WriteEntry(LL_MINIMAL, _T("Stopped %s service."), g_szServiceName);
	}
}

// service entry-point function
void WINAPI ServiceMain(DWORD /*dwArgc*/, LPTSTR /*apszArgv*/[])
{
	SERVICE_STATUS ss;

	g_hServiceStatus = ::RegisterServiceCtrlHandler(g_szServiceName, ServiceHandler);
	ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	ss.dwCurrentState = SERVICE_RUNNING;
	ss.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
	ss.dwWin32ExitCode = NO_ERROR;
	ss.dwServiceSpecificExitCode = 0;	// will be ignored
	ss.dwCheckPoint = 0;
	ss.dwWaitHint = 0;
	::SetServiceStatus(g_hServiceStatus, &ss);
	g_dwServiceState = ss.dwCurrentState;
	LogFile_WriteEntry(LL_MINIMAL, _T("Runned %s service."), g_szServiceName);
	AfxBeginThread(StartupProc, NULL);
}

// end of file
